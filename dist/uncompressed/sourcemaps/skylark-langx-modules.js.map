{"version":3,"sources":["skylark-langx-modules.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-langx-modules.js","sourcesContent":["define('skylark-langx-modules/modular',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"langx.modular\",{\r\n\t\tplugins : {\r\n\t\t\t\r\n\t\t}\r\n\t})\r\n});\ndefine('skylark-langx-modules/plugins/i18n',[\r\n    'module',\r\n    \"../modular\"\r\n], function (module,modular) {\r\n   'use strict';\r\n\r\n    //regexp for reconstructing the master bundle name from parts of the regexp match\r\n    //nlsRegExp.exec(\"foo/bar/baz/nls/en-ca/foo\") gives:\r\n    //[\"foo/bar/baz/nls/en-ca/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"en-ca\", \"foo\"]\r\n    //nlsRegExp.exec(\"foo/bar/baz/nls/foo\") gives:\r\n    //[\"foo/bar/baz/nls/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"foo\", \"\"]\r\n    //so, if match[5] is blank, it means this is the top bundle definition.\r\n    var nlsRegExp = /(^.*(^|\\/)nls(\\/|$))([^\\/]*)\\/?([^\\/]*)/;\r\n\r\n    //Helper function to avoid repeating code. Lots of arguments in the\r\n    //desire to stay functional and support RequireJS contexts without having\r\n    //to know about the RequireJS contexts.\r\n    function addPart(locale, master, needed, toLoad, prefix, suffix) {\r\n        if (master[locale]) {\r\n            needed.push(locale);\r\n            if (master[locale] === true || master[locale] === 1) {\r\n                toLoad.push(prefix + locale + '/' + suffix);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addIfExists(req, locale, toLoad, prefix, suffix) {\r\n        var fullName = prefix + locale + '/' + suffix;\r\n        if (require._fileExists(req.toUrl(fullName + '.js'))) {\r\n            toLoad.push(fullName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simple function to mix in properties from source into target,\r\n     * but only if target does not already have a property of the same name.\r\n     * This is not robust in IE for transferring methods that match\r\n     * Object.prototype names, but the uses of mixin here seem unlikely to\r\n     * trigger a problem related to that.\r\n     */\r\n    function mixin(target, source, force) {\r\n        var prop;\r\n        for (prop in source) {\r\n            if (source.hasOwnProperty(prop) && (!target.hasOwnProperty(prop) || force)) {\r\n                target[prop] = source[prop];\r\n            } else if (typeof source[prop] === 'object') {\r\n                if (!target[prop] && source[prop]) {\r\n                    target[prop] = {};\r\n                }\r\n                mixin(target[prop], source[prop], force);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    var masterConfig = module.config ? module.config() : {};\r\n\r\n    return modular.plugins.i18n = {\r\n        ///version: '2.0.4',\r\n        /**\r\n         * Called when a dependency needs to be loaded.\r\n         */\r\n        load: function (name, req, onLoad, config) {\r\n            config = config || {};\r\n\r\n            if (config.locale) {\r\n                masterConfig.locale = config.locale;\r\n            }\r\n\r\n            var masterName,\r\n                match = nlsRegExp.exec(name),\r\n                prefix = match[1],\r\n                locale = match[4],\r\n                suffix = match[5],\r\n                parts = locale.split(\"-\"),\r\n                toLoad = [],\r\n                value = {},\r\n                i, part, current = \"\";\r\n\r\n            //If match[5] is blank, it means this is the top bundle definition,\r\n            //so it does not have to be handled. Locale-specific requests\r\n            //will have a match[4] value but no match[5]\r\n            if (match[5]) {\r\n                //locale-specific bundle\r\n                prefix = match[1];\r\n                masterName = prefix + suffix;\r\n            } else {\r\n                //Top-level bundle.\r\n                masterName = name;\r\n                suffix = match[4];\r\n                locale = masterConfig.locale;\r\n                if (!locale) {\r\n                    locale = masterConfig.locale =\r\n                        typeof navigator === \"undefined\" ? \"root\" :\r\n                        (navigator.language ||\r\n                         navigator.userLanguage || \"root\").toLowerCase();\r\n                }\r\n                parts = locale.split(\"-\");\r\n            }\r\n\r\n            if (config.isBuild) {\r\n                //Check for existence of all locale possible files and\r\n                //require them if exist.\r\n                toLoad.push(masterName);\r\n                addIfExists(req, \"root\", toLoad, prefix, suffix);\r\n                for (i = 0; i < parts.length; i++) {\r\n                    part = parts[i];\r\n                    current += (current ? \"-\" : \"\") + part;\r\n                    addIfExists(req, current, toLoad, prefix, suffix);\r\n                }\r\n                                    \r\n                if(config.locales) {\r\n                \tvar j, k; \r\n                \tfor (j = 0; j < config.locales.length; j++) {\r\n                \t\tlocale = config.locales[j];\r\n                \t\tparts = locale.split(\"-\");\r\n                \t\tcurrent = \"\";\r\n                    \tfor (k = 0; k < parts.length; k++) {\r\n\t                        part = parts[k];\r\n\t                        current += (current ? \"-\" : \"\") + part;\r\n\t                        addIfExists(req, current, toLoad, prefix, suffix);\r\n                    \t}\r\n                \t}\r\n                }\r\n\r\n                req(toLoad, function () {\r\n                    onLoad();\r\n                });\r\n            } else {\r\n                //First, fetch the master bundle, it knows what locales are available.\r\n                req([masterName], function (master) {\r\n                    //Figure out the best fit\r\n                    var needed = [],\r\n                        part;\r\n\r\n                    //Always allow for root, then do the rest of the locale parts.\r\n                    addPart(\"root\", master, needed, toLoad, prefix, suffix);\r\n                    for (i = 0; i < parts.length; i++) {\r\n                        part = parts[i];\r\n                        current += (current ? \"-\" : \"\") + part;\r\n                        addPart(current, master, needed, toLoad, prefix, suffix);\r\n                    }\r\n\r\n                    //Load all the parts missing.\r\n                    req(toLoad, function () {\r\n                        var i, partBundle, part;\r\n                        for (i = needed.length - 1; i > -1 && needed[i]; i--) {\r\n                            part = needed[i];\r\n                            partBundle = master[part];\r\n                            if (partBundle === true || partBundle === 1) {\r\n                                partBundle = req(prefix + part + '/' + suffix);\r\n                            }\r\n                            mixin(value, partBundle);\r\n                        }\r\n\r\n                        //All done, notify the loader.\r\n                        onLoad(value);\r\n                    });\r\n                });\r\n            }\r\n        }\r\n    };\r\n});\r\n\ndefine('skylark-langx-modules/plugins/text',[\r\n    'module',\r\n    \"../modular\"\r\n], function (module,modular) {\r\n    'use strict';\r\n\r\n    var text, fs, Cc, Ci, xpcIsWindows,\r\n        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],\r\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im,\r\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im,\r\n        hasLocation = typeof location !== 'undefined' && location.href,\r\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\:/, ''),\r\n        defaultHostName = hasLocation && location.hostname,\r\n        defaultPort = hasLocation && (location.port || undefined),\r\n        buildMap = {},\r\n        masterConfig = (module.config && module.config()) || {};\r\n\r\n    text = modular.plugins.text = {\r\n        ///version: '2.0.12',\r\n\r\n        strip: function (content) {\r\n            //Strips <?xml ...?> declarations so that external SVG and XML\r\n            //documents can be added to a document without worry. Also, if the string\r\n            //is an HTML document, only the part inside the body tag is returned.\r\n            if (content) {\r\n                content = content.replace(xmlRegExp, \"\");\r\n                var matches = content.match(bodyRegExp);\r\n                if (matches) {\r\n                    content = matches[1];\r\n                }\r\n            } else {\r\n                content = \"\";\r\n            }\r\n            return content;\r\n        },\r\n\r\n        jsEscape: function (content) {\r\n            return content.replace(/(['\\\\])/g, '\\\\$1')\r\n                .replace(/[\\f]/g, \"\\\\f\")\r\n                .replace(/[\\b]/g, \"\\\\b\")\r\n                .replace(/[\\n]/g, \"\\\\n\")\r\n                .replace(/[\\t]/g, \"\\\\t\")\r\n                .replace(/[\\r]/g, \"\\\\r\")\r\n                .replace(/[\\u2028]/g, \"\\\\u2028\")\r\n                .replace(/[\\u2029]/g, \"\\\\u2029\");\r\n        },\r\n\r\n        createXhr: masterConfig.createXhr || function () {\r\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\r\n            var xhr, i, progId;\r\n            if (typeof XMLHttpRequest !== \"undefined\") {\r\n                return new XMLHttpRequest();\r\n            } else if (typeof ActiveXObject !== \"undefined\") {\r\n                for (i = 0; i < 3; i += 1) {\r\n                    progId = progIds[i];\r\n                    try {\r\n                        xhr = new ActiveXObject(progId);\r\n                    } catch (e) {}\r\n\r\n                    if (xhr) {\r\n                        progIds = [progId];  // so faster next time\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return xhr;\r\n        },\r\n\r\n        /**\r\n         * Parses a resource name into its component parts. Resource names\r\n         * look like: module/name.ext!strip, where the !strip part is\r\n         * optional.\r\n         * @param {String} name the resource name\r\n         * @returns {Object} with properties \"moduleName\", \"ext\" and \"strip\"\r\n         * where strip is a boolean.\r\n         */\r\n        parseName: function (name) {\r\n            var modName, ext, temp,\r\n                strip = false,\r\n                index = name.indexOf(\".\"),\r\n                isRelative = name.indexOf('./') === 0 ||\r\n                             name.indexOf('../') === 0;\r\n\r\n            if (index !== -1 && (!isRelative || index > 1)) {\r\n                modName = name.substring(0, index);\r\n                ext = name.substring(index + 1, name.length);\r\n            } else {\r\n                modName = name;\r\n            }\r\n\r\n            temp = ext || modName;\r\n            index = temp.indexOf(\"!\");\r\n            if (index !== -1) {\r\n                //Pull off the strip arg.\r\n                strip = temp.substring(index + 1) === \"strip\";\r\n                temp = temp.substring(0, index);\r\n                if (ext) {\r\n                    ext = temp;\r\n                } else {\r\n                    modName = temp;\r\n                }\r\n            }\r\n\r\n            return {\r\n                moduleName: modName,\r\n                ext: ext,\r\n                strip: strip\r\n            };\r\n        },\r\n\r\n        xdRegExp: /^((\\w+)\\:)?\\/\\/([^\\/\\\\]+)/,\r\n\r\n        /**\r\n         * Is an URL on another domain. Only works for browser use, returns\r\n         * false in non-browser environments. Only used to know if an\r\n         * optimized .js version of a text resource should be loaded\r\n         * instead.\r\n         * @param {String} url\r\n         * @returns Boolean\r\n         */\r\n        useXhr: function (url, protocol, hostname, port) {\r\n            var uProtocol, uHostName, uPort,\r\n                match = text.xdRegExp.exec(url);\r\n            if (!match) {\r\n                return true;\r\n            }\r\n            uProtocol = match[2];\r\n            uHostName = match[3];\r\n\r\n            uHostName = uHostName.split(':');\r\n            uPort = uHostName[1];\r\n            uHostName = uHostName[0];\r\n\r\n            return (!uProtocol || uProtocol === protocol) &&\r\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\r\n                   ((!uPort && !uHostName) || uPort === port);\r\n        },\r\n\r\n        finishLoad: function (name, strip, content, onLoad) {\r\n            content = strip ? text.strip(content) : content;\r\n            if (masterConfig.isBuild) {\r\n                buildMap[name] = content;\r\n            }\r\n            onLoad(content);\r\n        },\r\n\r\n        load: function (name, req, onLoad, config) {\r\n            //Name has format: some.module.filext!strip\r\n            //The strip part is optional.\r\n            //if strip is present, then that means only get the string contents\r\n            //inside a body tag in an HTML string. For XML/SVG content it means\r\n            //removing the <?xml ...?> declarations so the content can be inserted\r\n            //into the current doc without problems.\r\n\r\n            // Do not bother with the work if a build and text will\r\n            // not be inlined.\r\n            if (config && config.isBuild && !config.inlineText) {\r\n                onLoad();\r\n                return;\r\n            }\r\n\r\n            masterConfig.isBuild = config && config.isBuild;\r\n\r\n            var parsed = text.parseName(name),\r\n                nonStripName = parsed.moduleName +\r\n                    (parsed.ext ? '.' + parsed.ext : ''),\r\n                url = req.toUrl(nonStripName),\r\n                useXhr = (masterConfig.useXhr) ||\r\n                         text.useXhr;\r\n\r\n            // Do not load if it is an empty: url\r\n            if (url.indexOf('empty:') === 0) {\r\n                onLoad();\r\n                return;\r\n            }\r\n\r\n            //Load the text. Use XHR if possible and in a browser.\r\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\r\n                text.get(url, function (content) {\r\n                    text.finishLoad(name, parsed.strip, content, onLoad);\r\n                }, function (err) {\r\n                    if (onLoad.error) {\r\n                        onLoad.error(err);\r\n                    }\r\n                });\r\n            } else {\r\n                //Need to fetch the resource across domains. Assume\r\n                //the resource has been optimized into a JS module. Fetch\r\n                //by the module name + extension, but do not include the\r\n                //!strip part to avoid file system issues.\r\n                req([nonStripName], function (content) {\r\n                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,\r\n                                    parsed.strip, content, onLoad);\r\n                });\r\n            }\r\n        },\r\n\r\n        write: function (pluginName, moduleName, write, config) {\r\n            if (buildMap.hasOwnProperty(moduleName)) {\r\n                var content = text.jsEscape(buildMap[moduleName]);\r\n                write.asModule(pluginName + \"!\" + moduleName,\r\n                               \"define(function () { return '\" +\r\n                                   content +\r\n                               \"';});\\n\");\r\n            }\r\n        },\r\n\r\n        writeFile: function (pluginName, moduleName, req, write, config) {\r\n            var parsed = text.parseName(moduleName),\r\n                extPart = parsed.ext ? '.' + parsed.ext : '',\r\n                nonStripName = parsed.moduleName + extPart,\r\n                //Use a '.js' file name so that it indicates it is a\r\n                //script that can be loaded across domains.\r\n                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';\r\n\r\n            //Leverage own load() method to load plugin value, but only\r\n            //write out values that do not have the strip argument,\r\n            //to avoid any potential issues with ! in file names.\r\n            text.load(nonStripName, req, function (value) {\r\n                //Use own write() method to construct full module value.\r\n                //But need to create shell that translates writeFile's\r\n                //write() to the right interface.\r\n                var textWrite = function (contents) {\r\n                    return write(fileName, contents);\r\n                };\r\n                textWrite.asModule = function (moduleName, contents) {\r\n                    return write.asModule(moduleName, fileName, contents);\r\n                };\r\n\r\n                text.write(pluginName, nonStripName, textWrite, config);\r\n            }, config);\r\n        }\r\n    };\r\n\r\n    if (masterConfig.env === 'node' || (!masterConfig.env &&\r\n            typeof process !== \"undefined\" &&\r\n            process.versions &&\r\n            !!process.versions.node &&\r\n            !process.versions['node-webkit'])) {\r\n        //Using special require.nodeRequire, something added by r.js.\r\n        fs = require.nodeRequire('fs');\r\n\r\n        text.get = function (url, callback, errback) {\r\n            try {\r\n                var file = fs.readFileSync(url, 'utf8');\r\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\r\n                if (file.indexOf('\\uFEFF') === 0) {\r\n                    file = file.substring(1);\r\n                }\r\n                callback(file);\r\n            } catch (e) {\r\n                if (errback) {\r\n                    errback(e);\r\n                }\r\n            }\r\n        };\r\n    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&\r\n            text.createXhr())) {\r\n        text.get = function (url, callback, errback, headers) {\r\n            var xhr = text.createXhr(), header;\r\n            xhr.open('GET', url, true);\r\n\r\n            //Allow plugins direct access to xhr headers\r\n            if (headers) {\r\n                for (header in headers) {\r\n                    if (headers.hasOwnProperty(header)) {\r\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Allow overrides specified in config\r\n            if (masterConfig.onXhr) {\r\n                masterConfig.onXhr(xhr, url);\r\n            }\r\n\r\n            xhr.onreadystatechange = function (evt) {\r\n                var status, err;\r\n                //Do not explicitly handle errors, those should be\r\n                //visible via console output in the browser.\r\n                if (xhr.readyState === 4) {\r\n                    status = xhr.status || 0;\r\n                    if (status > 399 && status < 600) {\r\n                        //An http 4xx or 5xx error. Signal an error.\r\n                        err = new Error(url + ' HTTP status: ' + status);\r\n                        err.xhr = xhr;\r\n                        if (errback) {\r\n                            errback(err);\r\n                        }\r\n                    } else {\r\n                        callback(xhr.responseText);\r\n                    }\r\n\r\n                    if (masterConfig.onXhrComplete) {\r\n                        masterConfig.onXhrComplete(xhr, url);\r\n                    }\r\n                }\r\n            };\r\n            xhr.send(null);\r\n        };\r\n    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&\r\n            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {\r\n        //Why Java, why is this so awkward?\r\n        text.get = function (url, callback) {\r\n            var stringBuffer, line,\r\n                encoding = \"utf-8\",\r\n                file = new java.io.File(url),\r\n                lineSeparator = java.lang.System.getProperty(\"line.separator\"),\r\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\r\n                content = '';\r\n            try {\r\n                stringBuffer = new java.lang.StringBuffer();\r\n                line = input.readLine();\r\n\r\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\r\n                // http://www.unicode.org/faq/utf_bom.html\r\n\r\n                // Note that when we use utf-8, the BOM should appear as \"EF BB BF\", but it doesn't due to this bug in the JDK:\r\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\r\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\r\n                    // Eat the BOM, since we've already found the encoding on this file,\r\n                    // and we plan to concatenating this buffer with others; the BOM should\r\n                    // only appear at the top of a file.\r\n                    line = line.substring(1);\r\n                }\r\n\r\n                if (line !== null) {\r\n                    stringBuffer.append(line);\r\n                }\r\n\r\n                while ((line = input.readLine()) !== null) {\r\n                    stringBuffer.append(lineSeparator);\r\n                    stringBuffer.append(line);\r\n                }\r\n                //Make sure we return a JavaScript string and not a Java string.\r\n                content = String(stringBuffer.toString()); //String\r\n            } finally {\r\n                input.close();\r\n            }\r\n            callback(content);\r\n        };\r\n    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&\r\n            typeof Components !== 'undefined' && Components.classes &&\r\n            Components.interfaces)) {\r\n        //Avert your gaze!\r\n        Cc = Components.classes;\r\n        Ci = Components.interfaces;\r\n        Components.utils['import']('resource://gre/modules/FileUtils.jsm');\r\n        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);\r\n\r\n        text.get = function (url, callback) {\r\n            var inStream, convertStream, fileObj,\r\n                readData = {};\r\n\r\n            if (xpcIsWindows) {\r\n                url = url.replace(/\\//g, '\\\\');\r\n            }\r\n\r\n            fileObj = new FileUtils.File(url);\r\n\r\n            //XPCOM, you so crazy\r\n            try {\r\n                inStream = Cc['@mozilla.org/network/file-input-stream;1']\r\n                           .createInstance(Ci.nsIFileInputStream);\r\n                inStream.init(fileObj, 1, 0, false);\r\n\r\n                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']\r\n                                .createInstance(Ci.nsIConverterInputStream);\r\n                convertStream.init(inStream, \"utf-8\", inStream.available(),\r\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\r\n\r\n                convertStream.readString(inStream.available(), readData);\r\n                convertStream.close();\r\n                inStream.close();\r\n                callback(readData.value);\r\n            } catch (e) {\r\n                throw new Error((fileObj && fileObj.path || '') + ': ' + e);\r\n            }\r\n        };\r\n    }\r\n    return text;\r\n});\r\n\ndefine('skylark-langx-modules/plugins/json',[\r\n\"../modular\",\r\n'./text'\r\n], function(modules,modular) {\r\n    'use strict';\r\n\r\n\tvar map = Object.create(null);\r\n\t\r\n\treturn modular.plugins.json = {\r\n        load : function(name, req, onLoad, config) {\r\n    \t\ttext.get(req.toUrl(name), function(json) {\r\n                    if (config.isBuild) {\r\n                    \tmap[name] = json; //during build caching: http://requirejs.org/docs/plugins.html#apiwrite\r\n                        onLoad(json);\r\n                    } else {\r\n                        try {\r\n                            var _json = JSON.parse(json);\r\n                        } catch (e) {\r\n                            onLoad.error(e);\r\n                        }\r\n                        onLoad(_json);\r\n                    }\r\n                },\r\n                onLoad.error, \r\n                {accept: 'application/json'} //$NON-NLS-1$\r\n             );\r\n\t\t},\r\n\t\twrite : function(pluginName, moduleName, write) {\r\n\t\t\tvar _json = map[moduleName];\r\n            if(_json) {\r\n                write('define(\"'+ pluginName +'!'+ moduleName +'\", function(){ return '+ _json +';});\\n'); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\r\n            }\r\n        }\r\n\t};\r\n});\ndefine('skylark-langx-modules/plugins/order',[\r\n\"../modular\"\r\n],function(modular){\r\n    //Sadly necessary browser inference due to differences in the way\r\n    //that browsers load and execute dynamically inserted javascript\r\n    //and whether the script/cache method works when ordered execution is\r\n    //desired. Currently, Gecko and Opera do not load/fire onload for scripts with\r\n    //type=\"script/cache\" but they execute injected scripts in order\r\n    //unless the 'async' flag is present.\r\n    //However, this is all changing in latest browsers implementing HTML5\r\n    //spec. With compliant browsers .async true by default, and\r\n    //if false, then it will execute in order. Favor that test first for forward\r\n    //compatibility.\r\n    var testScript = typeof document !== \"undefined\" &&\r\n                 typeof window !== \"undefined\" &&\r\n                 document.createElement(\"script\"),\r\n\r\n        supportsInOrderExecution = testScript && (testScript.async ||\r\n                               ((window.opera &&\r\n                                 Object.prototype.toString.call(window.opera) === \"[object Opera]\") ||\r\n                               //If Firefox 2 does not have to be supported, then\r\n                               //a better check may be:\r\n                               //('mozIsLocallyAvailable' in window.navigator)\r\n                               (\"MozAppearance\" in document.documentElement.style))),\r\n\r\n        //This test is true for IE browsers, which will load scripts but only\r\n        //execute them once the script is added to the DOM.\r\n        supportsLoadSeparateFromExecute = testScript &&\r\n                                          testScript.readyState === 'uninitialized',\r\n\r\n        readyRegExp = /^(complete|loaded)$/,\r\n        cacheWaiting = [],\r\n        cached = {},\r\n        scriptNodes = {},\r\n        scriptWaiting = [];\r\n\r\n    //Done with the test script.\r\n    testScript = null;\r\n\r\n    //Callback used by the type=\"script/cache\" callback that indicates a script\r\n    //has finished downloading.\r\n    function scriptCacheCallback(evt) {\r\n        var node = evt.currentTarget || evt.srcElement, i,\r\n            moduleName, resource;\r\n\r\n        if (evt.type === \"load\" || readyRegExp.test(node.readyState)) {\r\n            //Pull out the name of the module and the context.\r\n            moduleName = node.getAttribute(\"data-requiremodule\");\r\n\r\n            //Mark this cache request as loaded\r\n            cached[moduleName] = true;\r\n\r\n            //Find out how many ordered modules have loaded\r\n            for (i = 0; (resource = cacheWaiting[i]); i++) {\r\n                if (cached[resource.name]) {\r\n                    resource.req([resource.name], resource.onLoad);\r\n                } else {\r\n                    //Something in the ordered list is not loaded,\r\n                    //so wait.\r\n                    break;\r\n                }\r\n            }\r\n\r\n            //If just loaded some items, remove them from cacheWaiting.\r\n            if (i > 0) {\r\n                cacheWaiting.splice(0, i);\r\n            }\r\n\r\n            //Remove this script tag from the DOM\r\n            //Use a setTimeout for cleanup because some older IE versions vomit\r\n            //if removing a script node while it is being evaluated.\r\n            setTimeout(function () {\r\n                node.parentNode.removeChild(node);\r\n            }, 15);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used for the IE case, where fetching is done by creating script element\r\n     * but not attaching it to the DOM. This function will be called when that\r\n     * happens so it can be determined when the node can be attached to the\r\n     * DOM to trigger its execution.\r\n     */\r\n    function onFetchOnly(node) {\r\n        var i, loadedNode, resourceName;\r\n\r\n        //Mark this script as loaded.\r\n        node.setAttribute('data-orderloaded', 'loaded');\r\n\r\n        //Cycle through waiting scripts. If the matching node for them\r\n        //is loaded, and is in the right order, add it to the DOM\r\n        //to execute the script.\r\n        for (i = 0; (resourceName = scriptWaiting[i]); i++) {\r\n            loadedNode = scriptNodes[resourceName];\r\n            if (loadedNode &&\r\n                loadedNode.getAttribute('data-orderloaded') === 'loaded') {\r\n                delete scriptNodes[resourceName];\r\n                require.addScriptToDom(loadedNode);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        //If just loaded some items, remove them from waiting.\r\n        if (i > 0) {\r\n            scriptWaiting.splice(0, i);\r\n        }\r\n    }\r\n\r\n    return modular.plugins.order = {\r\n        ///version: '1.0.5',\r\n\r\n        load: function (name, req, onLoad, config) {\r\n            var hasToUrl = !!req.nameToUrl,\r\n                url, node, context;\r\n\r\n            //If no nameToUrl, then probably a build with a loader that\r\n            //does not support it, and all modules are inlined.\r\n            if (!hasToUrl) {\r\n                req([name], onLoad);\r\n                return;\r\n            }\r\n\r\n            url = req.nameToUrl(name, null);\r\n\r\n            //Make sure the async attribute is not set for any pathway involving\r\n            //this script.\r\n            require.s.skipAsync[url] = true;\r\n            if (supportsInOrderExecution || config.isBuild) {\r\n                //Just a normal script tag append, but without async attribute\r\n                //on the script.\r\n                req([name], onLoad);\r\n            } else if (supportsLoadSeparateFromExecute) {\r\n                //Just fetch the URL, but do not execute it yet. The\r\n                //non-standards IE case. Really not so nice because it is\r\n                //assuming and touching requrejs internals. OK though since\r\n                //ordered execution should go away after a long while.\r\n                context = require.s.contexts._;\r\n\r\n                if (!context.urlFetched[url] && !context.loaded[name]) {\r\n                    //Indicate the script is being fetched.\r\n                    context.urlFetched[url] = true;\r\n\r\n                    //Stuff from require.load\r\n                    require.resourcesReady(false);\r\n                    context.scriptCount += 1;\r\n\r\n                    //Fetch the script now, remember it.\r\n                    node = require.attach(url, context, name, null, null, onFetchOnly);\r\n                    scriptNodes[name] = node;\r\n                    scriptWaiting.push(name);\r\n                }\r\n\r\n                //Do a normal require for it, once it loads, use it as return\r\n                //value.\r\n                req([name], onLoad);\r\n            } else {\r\n                //Credit to LABjs author Kyle Simpson for finding that scripts\r\n                //with type=\"script/cache\" allow scripts to be downloaded into\r\n                //browser cache but not executed. Use that\r\n                //so that subsequent addition of a real type=\"text/javascript\"\r\n                //tag will cause the scripts to be executed immediately in the\r\n                //correct order.\r\n                if (req.specified(name)) {\r\n                    req([name], onLoad);\r\n                } else {\r\n                    cacheWaiting.push({\r\n                        name: name,\r\n                        req: req,\r\n                        onLoad: onLoad\r\n                    });\r\n                    require.attach(url, null, name, scriptCacheCallback, \"script/cache\");\r\n                }\r\n            }\r\n        }\r\n    };\r\n});\r\n\r\n\ndefine('skylark-langx-modules/plugins/ready',[\r\n\"../modular\"\r\n],function(modular){\r\n    'use strict';\r\n\r\n    var isTop, testDiv, scrollIntervalId,\r\n        isBrowser = typeof window !== \"undefined\" && window.document,\r\n        isPageLoaded = !isBrowser,\r\n        doc = isBrowser ? document : null,\r\n        readyCalls = [];\r\n\r\n    function runCallbacks(callbacks) {\r\n        var i;\r\n        for (i = 0; i < callbacks.length; i += 1) {\r\n            callbacks[i](doc);\r\n        }\r\n    }\r\n\r\n    function callReady() {\r\n        var callbacks = readyCalls;\r\n\r\n        if (isPageLoaded) {\r\n            //Call the DOM ready callbacks\r\n            if (callbacks.length) {\r\n                readyCalls = [];\r\n                runCallbacks(callbacks);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the page as loaded.\r\n     */\r\n    function pageLoaded() {\r\n        if (!isPageLoaded) {\r\n            isPageLoaded = true;\r\n            if (scrollIntervalId) {\r\n                clearInterval(scrollIntervalId);\r\n            }\r\n\r\n            callReady();\r\n        }\r\n    }\r\n\r\n    if (isBrowser) {\r\n        if (document.addEventListener) {\r\n            //Standards. Hooray! Assumption here that if standards based,\r\n            //it knows about DOMContentLoaded.\r\n            document.addEventListener(\"DOMContentLoaded\", pageLoaded, false);\r\n            window.addEventListener(\"load\", pageLoaded, false);\r\n        } else if (window.attachEvent) {\r\n            window.attachEvent(\"onload\", pageLoaded);\r\n\r\n            testDiv = document.createElement('div');\r\n            try {\r\n                isTop = window.frameElement === null;\r\n            } catch (e) {}\r\n\r\n            //DOMContentLoaded approximation that uses a doScroll, as found by\r\n            //Diego Perini: http://javascript.nwbox.com/IEContentLoaded/,\r\n            //but modified by other contributors, including jdalton\r\n            if (testDiv.doScroll && isTop && window.external) {\r\n                scrollIntervalId = setInterval(function () {\r\n                    try {\r\n                        testDiv.doScroll();\r\n                        pageLoaded();\r\n                    } catch (e) {}\r\n                }, 30);\r\n            }\r\n        }\r\n\r\n        //Check if document already complete, and if so, just trigger page load\r\n        //listeners. Latest webkit browsers also use \"interactive\", and\r\n        //will fire the onDOMContentLoaded before \"interactive\" but not after\r\n        //entering \"interactive\" or \"complete\". More details:\r\n        //http://dev.w3.org/html5/spec/the-end.html#the-end\r\n        //http://stackoverflow.com/questions/3665561/document-readystate-of-interactive-vs-ondomcontentloaded\r\n        //Hmm, this is more complicated on further use, see \"firing too early\"\r\n        //bug: https://github.com/requirejs/domReady/issues/1\r\n        //so removing the || document.readyState === \"interactive\" test.\r\n        //There is still a window.onload binding that should get fired if\r\n        //DOMContentLoaded is missed.\r\n        if (document.readyState === \"complete\") {\r\n            pageLoaded();\r\n        }\r\n    }\r\n\r\n    /** START OF PUBLIC API **/\r\n\r\n    /**\r\n     * Registers a callback for DOM ready. If DOM is already ready, the\r\n     * callback is called immediately.\r\n     * @param {Function} callback\r\n     */\r\n    function domReady(callback) {\r\n        if (isPageLoaded) {\r\n            callback(doc);\r\n        } else {\r\n            readyCalls.push(callback);\r\n        }\r\n        return domReady;\r\n    }\r\n\r\n    ///domReady.version = '2.0.1';\r\n\r\n    /**\r\n     * Loader Plugin API method\r\n     */\r\n    domReady.load = function (name, req, onLoad, config) {\r\n        if (config.isBuild) {\r\n            onLoad(null);\r\n        } else {\r\n            domReady(onLoad);\r\n        }\r\n    };\r\n\r\n    /** END OF PUBLIC API **/\r\n\r\n    return modular.plugins.ready = domReady;\r\n});\r\n\ndefine('skylark-langx-modules/main',[\r\n\t\"./modular\",\r\n\t\"./plugins/i18n\",\r\n\t\"./plugins/json\",\r\n\t\"./plugins/order\",\r\n\t\"./plugins/ready\",\r\n\t\"./plugins/text\"\r\n],function(modular){\r\n\treturn modular;\r\n});\ndefine('skylark-langx-modules', ['skylark-langx-modules/main'], function (main) { return main; });\n\n"]}