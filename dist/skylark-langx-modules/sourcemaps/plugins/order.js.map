{"version":3,"sources":["plugins/order.js"],"names":["define","modular","testScript","document","window","createElement","supportsInOrderExecution","async","opera","Object","prototype","toString","call","documentElement","style","supportsLoadSeparateFromExecute","readyState","readyRegExp","cacheWaiting","cached","scriptNodes","scriptWaiting","scriptCacheCallback","evt","i","moduleName","resource","node","currentTarget","srcElement","type","test","getAttribute","name","req","onLoad","splice","setTimeout","parentNode","removeChild","onFetchOnly","loadedNode","resourceName","setAttribute","require","addScriptToDom","plugins","order","load","config","url","context","nameToUrl","s","skipAsync","isBuild","contexts","_","urlFetched","loaded","resourcesReady","scriptCount","attach","push","specified"],"mappings":";;;;;;;AAAAA,QACA,cACE,SAASC,GAWP,IAAIC,EAAiC,oBAAbC,UACO,oBAAXC,QACPD,SAASE,cAAc,UAEhCC,EAA2BJ,IAAeA,EAAWK,OAC5BH,OAAOI,OAC0C,mBAAjDC,OAAOC,UAAUC,SAASC,KAAKR,OAAOI,QAIvC,kBAAmBL,SAASU,gBAAgBC,OAIpEC,EAAkCb,GAC0B,kBAA1BA,EAAWc,WAE7CC,EAAc,sBACdC,KACAC,KACAC,KACAC,KAOJ,SAASC,EAAoBC,GACzB,IAAgDC,EAC5CC,EAAYC,EADZC,EAAOJ,EAAIK,eAAiBL,EAAIM,WAGpC,GAAiB,SAAbN,EAAIO,MAAmBb,EAAYc,KAAKJ,EAAKX,YAAa,CAQ1D,IANAS,EAAaE,EAAKK,aAAa,sBAG/Bb,EAAOM,IAAc,EAGhBD,EAAI,GAAIE,EAAWR,EAAaM,KAC7BL,EAAOO,EAASO,MADkBT,IAElCE,EAASQ,KAAKR,EAASO,MAAOP,EAASS,QAS3CX,EAAI,GACJN,EAAakB,OAAO,EAAGZ,GAM3Ba,WAAW,WACPV,EAAKW,WAAWC,YAAYZ,IAC7B,KAUX,SAASa,EAAYb,GACjB,IAAIH,EAAGiB,EAAYC,EAQnB,IALAf,EAAKgB,aAAa,mBAAoB,UAKjCnB,EAAI,GAAIkB,EAAerB,EAAcG,OACtCiB,EAAarB,EAAYsB,KAE2B,WAAhDD,EAAWT,aAAa,qBAHeR,WAIhCJ,EAAYsB,GACnBE,QAAQC,eAAeJ,GAO3BjB,EAAI,GACJH,EAAce,OAAO,EAAGZ,GAIhC,OAxEAtB,EAAa,KAwEND,EAAQ6C,QAAQC,OAGnBC,KAAM,SAAUf,EAAMC,EAAKC,EAAQc,GAC/B,IACIC,EAAKvB,EAAMwB,GADEjB,EAAIkB,UAMjBlB,GAAKD,GAAOE,IAIhBe,EAAMhB,EAAIkB,UAAUnB,EAAM,MAI1BW,QAAQS,EAAEC,UAAUJ,IAAO,EACvB5C,GAA4B2C,EAAOM,QAGnCrB,GAAKD,GAAOE,GACLpB,IAKPoC,EAAUP,QAAQS,EAAEG,SAASC,GAEhBC,WAAWR,IAASC,EAAQQ,OAAO1B,KAE5CkB,EAAQO,WAAWR,IAAO,EAG1BN,QAAQgB,gBAAe,GACvBT,EAAQU,aAAe,EAGvBlC,EAAOiB,QAAQkB,OAAOZ,EAAKC,EAASlB,EAAM,KAAM,KAAMO,GACtDpB,EAAYa,GAAQN,EACpBN,EAAc0C,KAAK9B,IAKvBC,GAAKD,GAAOE,IAQRD,EAAI8B,UAAU/B,GACdC,GAAKD,GAAOE,IAEZjB,EAAa6C,MACT9B,KAAMA,EACNC,IAAKA,EACLC,OAAQA,IAEZS,QAAQkB,OAAOZ,EAAK,KAAMjB,EAAMX,EAAqB","file":"../../plugins/order.js","sourcesContent":["define([\r\n\"../modular\"\r\n],function(modular){\r\n    //Sadly necessary browser inference due to differences in the way\r\n    //that browsers load and execute dynamically inserted javascript\r\n    //and whether the script/cache method works when ordered execution is\r\n    //desired. Currently, Gecko and Opera do not load/fire onload for scripts with\r\n    //type=\"script/cache\" but they execute injected scripts in order\r\n    //unless the 'async' flag is present.\r\n    //However, this is all changing in latest browsers implementing HTML5\r\n    //spec. With compliant browsers .async true by default, and\r\n    //if false, then it will execute in order. Favor that test first for forward\r\n    //compatibility.\r\n    var testScript = typeof document !== \"undefined\" &&\r\n                 typeof window !== \"undefined\" &&\r\n                 document.createElement(\"script\"),\r\n\r\n        supportsInOrderExecution = testScript && (testScript.async ||\r\n                               ((window.opera &&\r\n                                 Object.prototype.toString.call(window.opera) === \"[object Opera]\") ||\r\n                               //If Firefox 2 does not have to be supported, then\r\n                               //a better check may be:\r\n                               //('mozIsLocallyAvailable' in window.navigator)\r\n                               (\"MozAppearance\" in document.documentElement.style))),\r\n\r\n        //This test is true for IE browsers, which will load scripts but only\r\n        //execute them once the script is added to the DOM.\r\n        supportsLoadSeparateFromExecute = testScript &&\r\n                                          testScript.readyState === 'uninitialized',\r\n\r\n        readyRegExp = /^(complete|loaded)$/,\r\n        cacheWaiting = [],\r\n        cached = {},\r\n        scriptNodes = {},\r\n        scriptWaiting = [];\r\n\r\n    //Done with the test script.\r\n    testScript = null;\r\n\r\n    //Callback used by the type=\"script/cache\" callback that indicates a script\r\n    //has finished downloading.\r\n    function scriptCacheCallback(evt) {\r\n        var node = evt.currentTarget || evt.srcElement, i,\r\n            moduleName, resource;\r\n\r\n        if (evt.type === \"load\" || readyRegExp.test(node.readyState)) {\r\n            //Pull out the name of the module and the context.\r\n            moduleName = node.getAttribute(\"data-requiremodule\");\r\n\r\n            //Mark this cache request as loaded\r\n            cached[moduleName] = true;\r\n\r\n            //Find out how many ordered modules have loaded\r\n            for (i = 0; (resource = cacheWaiting[i]); i++) {\r\n                if (cached[resource.name]) {\r\n                    resource.req([resource.name], resource.onLoad);\r\n                } else {\r\n                    //Something in the ordered list is not loaded,\r\n                    //so wait.\r\n                    break;\r\n                }\r\n            }\r\n\r\n            //If just loaded some items, remove them from cacheWaiting.\r\n            if (i > 0) {\r\n                cacheWaiting.splice(0, i);\r\n            }\r\n\r\n            //Remove this script tag from the DOM\r\n            //Use a setTimeout for cleanup because some older IE versions vomit\r\n            //if removing a script node while it is being evaluated.\r\n            setTimeout(function () {\r\n                node.parentNode.removeChild(node);\r\n            }, 15);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used for the IE case, where fetching is done by creating script element\r\n     * but not attaching it to the DOM. This function will be called when that\r\n     * happens so it can be determined when the node can be attached to the\r\n     * DOM to trigger its execution.\r\n     */\r\n    function onFetchOnly(node) {\r\n        var i, loadedNode, resourceName;\r\n\r\n        //Mark this script as loaded.\r\n        node.setAttribute('data-orderloaded', 'loaded');\r\n\r\n        //Cycle through waiting scripts. If the matching node for them\r\n        //is loaded, and is in the right order, add it to the DOM\r\n        //to execute the script.\r\n        for (i = 0; (resourceName = scriptWaiting[i]); i++) {\r\n            loadedNode = scriptNodes[resourceName];\r\n            if (loadedNode &&\r\n                loadedNode.getAttribute('data-orderloaded') === 'loaded') {\r\n                delete scriptNodes[resourceName];\r\n                require.addScriptToDom(loadedNode);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        //If just loaded some items, remove them from waiting.\r\n        if (i > 0) {\r\n            scriptWaiting.splice(0, i);\r\n        }\r\n    }\r\n\r\n    return modular.plugins.order = {\r\n        ///version: '1.0.5',\r\n\r\n        load: function (name, req, onLoad, config) {\r\n            var hasToUrl = !!req.nameToUrl,\r\n                url, node, context;\r\n\r\n            //If no nameToUrl, then probably a build with a loader that\r\n            //does not support it, and all modules are inlined.\r\n            if (!hasToUrl) {\r\n                req([name], onLoad);\r\n                return;\r\n            }\r\n\r\n            url = req.nameToUrl(name, null);\r\n\r\n            //Make sure the async attribute is not set for any pathway involving\r\n            //this script.\r\n            require.s.skipAsync[url] = true;\r\n            if (supportsInOrderExecution || config.isBuild) {\r\n                //Just a normal script tag append, but without async attribute\r\n                //on the script.\r\n                req([name], onLoad);\r\n            } else if (supportsLoadSeparateFromExecute) {\r\n                //Just fetch the URL, but do not execute it yet. The\r\n                //non-standards IE case. Really not so nice because it is\r\n                //assuming and touching requrejs internals. OK though since\r\n                //ordered execution should go away after a long while.\r\n                context = require.s.contexts._;\r\n\r\n                if (!context.urlFetched[url] && !context.loaded[name]) {\r\n                    //Indicate the script is being fetched.\r\n                    context.urlFetched[url] = true;\r\n\r\n                    //Stuff from require.load\r\n                    require.resourcesReady(false);\r\n                    context.scriptCount += 1;\r\n\r\n                    //Fetch the script now, remember it.\r\n                    node = require.attach(url, context, name, null, null, onFetchOnly);\r\n                    scriptNodes[name] = node;\r\n                    scriptWaiting.push(name);\r\n                }\r\n\r\n                //Do a normal require for it, once it loads, use it as return\r\n                //value.\r\n                req([name], onLoad);\r\n            } else {\r\n                //Credit to LABjs author Kyle Simpson for finding that scripts\r\n                //with type=\"script/cache\" allow scripts to be downloaded into\r\n                //browser cache but not executed. Use that\r\n                //so that subsequent addition of a real type=\"text/javascript\"\r\n                //tag will cause the scripts to be executed immediately in the\r\n                //correct order.\r\n                if (req.specified(name)) {\r\n                    req([name], onLoad);\r\n                } else {\r\n                    cacheWaiting.push({\r\n                        name: name,\r\n                        req: req,\r\n                        onLoad: onLoad\r\n                    });\r\n                    require.attach(url, null, name, scriptCacheCallback, \"script/cache\");\r\n                }\r\n            }\r\n        }\r\n    };\r\n});\r\n\r\n"]}