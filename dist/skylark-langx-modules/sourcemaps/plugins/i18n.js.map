{"version":3,"sources":["plugins/i18n.js"],"names":["define","module","modular","nlsRegExp","addPart","locale","master","needed","toLoad","prefix","suffix","push","addIfExists","req","fullName","require","_fileExists","toUrl","mixin","target","source","force","prop","hasOwnProperty","masterConfig","config","plugins","i18n","load","name","onLoad","masterName","i","part","match","exec","parts","split","value","current","navigator","language","userLanguage","toLowerCase","isBuild","length","j","k","locales","partBundle"],"mappings":"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","file":"../../plugins/i18n.js","sourcesContent":["define([\r\n    'module',\r\n    \"../modular\"\r\n], function (module,modular) {\r\n   'use strict';\r\n\r\n    //regexp for reconstructing the master bundle name from parts of the regexp match\r\n    //nlsRegExp.exec(\"foo/bar/baz/nls/en-ca/foo\") gives:\r\n    //[\"foo/bar/baz/nls/en-ca/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"en-ca\", \"foo\"]\r\n    //nlsRegExp.exec(\"foo/bar/baz/nls/foo\") gives:\r\n    //[\"foo/bar/baz/nls/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"foo\", \"\"]\r\n    //so, if match[5] is blank, it means this is the top bundle definition.\r\n    var nlsRegExp = /(^.*(^|\\/)nls(\\/|$))([^\\/]*)\\/?([^\\/]*)/;\r\n\r\n    //Helper function to avoid repeating code. Lots of arguments in the\r\n    //desire to stay functional and support RequireJS contexts without having\r\n    //to know about the RequireJS contexts.\r\n    function addPart(locale, master, needed, toLoad, prefix, suffix) {\r\n        if (master[locale]) {\r\n            needed.push(locale);\r\n            if (master[locale] === true || master[locale] === 1) {\r\n                toLoad.push(prefix + locale + '/' + suffix);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addIfExists(req, locale, toLoad, prefix, suffix) {\r\n        var fullName = prefix + locale + '/' + suffix;\r\n        if (require._fileExists(req.toUrl(fullName + '.js'))) {\r\n            toLoad.push(fullName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simple function to mix in properties from source into target,\r\n     * but only if target does not already have a property of the same name.\r\n     * This is not robust in IE for transferring methods that match\r\n     * Object.prototype names, but the uses of mixin here seem unlikely to\r\n     * trigger a problem related to that.\r\n     */\r\n    function mixin(target, source, force) {\r\n        var prop;\r\n        for (prop in source) {\r\n            if (source.hasOwnProperty(prop) && (!target.hasOwnProperty(prop) || force)) {\r\n                target[prop] = source[prop];\r\n            } else if (typeof source[prop] === 'object') {\r\n                if (!target[prop] && source[prop]) {\r\n                    target[prop] = {};\r\n                }\r\n                mixin(target[prop], source[prop], force);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    var masterConfig = module.config ? module.config() : {};\r\n\r\n    return modular.plugins.i18n = {\r\n        ///version: '2.0.4',\r\n        /**\r\n         * Called when a dependency needs to be loaded.\r\n         */\r\n        load: function (name, req, onLoad, config) {\r\n            config = config || {};\r\n\r\n            if (config.locale) {\r\n                masterConfig.locale = config.locale;\r\n            }\r\n\r\n            var masterName,\r\n                match = nlsRegExp.exec(name),\r\n                prefix = match[1],\r\n                locale = match[4],\r\n                suffix = match[5],\r\n                parts = locale.split(\"-\"),\r\n                toLoad = [],\r\n                value = {},\r\n                i, part, current = \"\";\r\n\r\n            //If match[5] is blank, it means this is the top bundle definition,\r\n            //so it does not have to be handled. Locale-specific requests\r\n            //will have a match[4] value but no match[5]\r\n            if (match[5]) {\r\n                //locale-specific bundle\r\n                prefix = match[1];\r\n                masterName = prefix + suffix;\r\n            } else {\r\n                //Top-level bundle.\r\n                masterName = name;\r\n                suffix = match[4];\r\n                locale = masterConfig.locale;\r\n                if (!locale) {\r\n                    locale = masterConfig.locale =\r\n                        typeof navigator === \"undefined\" ? \"root\" :\r\n                        (navigator.language ||\r\n                         navigator.userLanguage || \"root\").toLowerCase();\r\n                }\r\n                parts = locale.split(\"-\");\r\n            }\r\n\r\n            if (config.isBuild) {\r\n                //Check for existence of all locale possible files and\r\n                //require them if exist.\r\n                toLoad.push(masterName);\r\n                addIfExists(req, \"root\", toLoad, prefix, suffix);\r\n                for (i = 0; i < parts.length; i++) {\r\n                    part = parts[i];\r\n                    current += (current ? \"-\" : \"\") + part;\r\n                    addIfExists(req, current, toLoad, prefix, suffix);\r\n                }\r\n                                    \r\n                if(config.locales) {\r\n                \tvar j, k; \r\n                \tfor (j = 0; j < config.locales.length; j++) {\r\n                \t\tlocale = config.locales[j];\r\n                \t\tparts = locale.split(\"-\");\r\n                \t\tcurrent = \"\";\r\n                    \tfor (k = 0; k < parts.length; k++) {\r\n\t                        part = parts[k];\r\n\t                        current += (current ? \"-\" : \"\") + part;\r\n\t                        addIfExists(req, current, toLoad, prefix, suffix);\r\n                    \t}\r\n                \t}\r\n                }\r\n\r\n                req(toLoad, function () {\r\n                    onLoad();\r\n                });\r\n            } else {\r\n                //First, fetch the master bundle, it knows what locales are available.\r\n                req([masterName], function (master) {\r\n                    //Figure out the best fit\r\n                    var needed = [],\r\n                        part;\r\n\r\n                    //Always allow for root, then do the rest of the locale parts.\r\n                    addPart(\"root\", master, needed, toLoad, prefix, suffix);\r\n                    for (i = 0; i < parts.length; i++) {\r\n                        part = parts[i];\r\n                        current += (current ? \"-\" : \"\") + part;\r\n                        addPart(current, master, needed, toLoad, prefix, suffix);\r\n                    }\r\n\r\n                    //Load all the parts missing.\r\n                    req(toLoad, function () {\r\n                        var i, partBundle, part;\r\n                        for (i = needed.length - 1; i > -1 && needed[i]; i--) {\r\n                            part = needed[i];\r\n                            partBundle = master[part];\r\n                            if (partBundle === true || partBundle === 1) {\r\n                                partBundle = req(prefix + part + '/' + suffix);\r\n                            }\r\n                            mixin(value, partBundle);\r\n                        }\r\n\r\n                        //All done, notify the loader.\r\n                        onLoad(value);\r\n                    });\r\n                });\r\n            }\r\n        }\r\n    };\r\n});\r\n"]}